---
title: QCon London 2013
date: 2013-03-12 00:00:00 +0000
header:
  overlay_color: "#338"
excerpt: ""
---

I was fortunate enough to attend [QCon London](http://qconlondon.com/) this year courtesy of [Black Pepper](https://www.blackpepper.co.uk/). Out of the many interesting sessions, a series of talks centred around Web application architecture and [REST](http://en.wikipedia.org/wiki/Representational_state_transfer) particularly caught my imagination.

[Stefan Tilkov](https://twitter.com/stilkov) began by holding a mirror up to the modern webapp architecture in his talk, "[Web Development: You're Doing it Wrong](http://www.infoq.com/presentations/web-development-techniques)". He outlined a number of typical UI smells, such as the back button not working as expected and the inability to open multiple windows, that indicate that perhaps your architecture is fighting the model of the web. These problems tend to arise when we use a higher-level web framework to abstract ourselves away from the underlying web technologies (HTML, CSS, JavaScript) and the properties of HTTP (statelessness, client-server). Stefan argued that by attempting to overcome these problems, web frameworks ultimately evolve into primitive web-like architectures that foolishly try to re-solve the problems that the web itself has already solved. It's much easier to work with the web rather than fight against it.

Stefan proposed a hybrid style between traditional server-side UI components and modern [single-page applications](http://en.wikipedia.org/wiki/Single-page_application) (SPA) that takes the best characteristics of each, which he dubbed '[Resource-Orientated Client Architecture](http://roca-style.org/)' (ROCA). ROCA is a set of recommendations that describe how your application can be of the web, rather than just on the web. Central to this style is the subtle concept that the UI becomes merely a [semantic HTML](http://en.wikipedia.org/wiki/Semantic_HTML) representation of its RESTful service.

[Rickard Ã–berg](https://twitter.com/rickardoberg) complimented these ideas in his talk, "[Road to REST](http://www.infoq.com/presentations/REST-API-HATEOAS)". He described the design evolution of a RESTful service that provided the back-end to various client platforms. The lessons learnt were two-fold: firstly, the resources exposed by the service should correlate to use-cases, rather than entities; and secondly, the often neglected [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS) constraint of REST allows clients to discover, and adapt to, server changes. Embracing these ideas again blurs the boundary between RESTful services and their UI, or as Rickard aptly put it, "a good REST API is like an ugly website".

Taking this concept further was [Jon Moore](https://twitter.com/jon_moore) in his talk, "[Building Hypermedia APIs with HTML](http://www.infoq.com/presentations/web-api-html)", where he proposed using HTML itself as the hypermedia representation for RESTful services. This approach has [many advantages](http://codeartisan.blogspot.co.uk/2012/07/using-html-as-media-type-for-your-api.html) over JSON or other XML representations, for example: web browsers implicitly become clients of your API; HTML already has comprehensive hypermedia support; and HTML5 provides semantic metadata in the form of [HTML Microdata](http://en.wikipedia.org/wiki/Microdata_(HTML)). He demonstrated a simple command line tool that was able to programmatically explore and use any REST API written to these principals, much like a user can navigate any website. Once again we witness the trend of unifying human and computer interaction with web services.

Looking into the future, [Mike Amundsen](https://twitter.com/mamund) hypothesised how these ideas may evolve in his talk, "[Generic Hypermedia and Domain-Specific APIs: RESTing in the ALPS](http://www.infoq.com/presentations/web-api-alps)". He highlighted concern over the [recent explosion](http://www.programmableweb.com/apis/directory) in web service APIs, specifically as they tend to be proprietary rather than domain-specific. For example, there are hundreds of shopping APIs but there is no single standardised API to access them all through. Mike proposed that we need a common language to standardise domain-specific APIs, much like [schema.org](http://schema.org/) does for domain-specific data, which he calls [Application-Level Profile Semantics](http://amundsen.com/hypermedia/profiles/) (ALPS). It is very much a work-in-progress but it has great potential to take us towards the fabled semantic web.
